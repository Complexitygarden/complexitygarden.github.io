# -*- coding: utf-8 -*-
"""app.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1YRKwmv8h4K4WWOwAvuKFbuSI6S-Kavg0
"""

from flask import Flask, render_template, request
from collections import deque

app = Flask(__name__)

@app.route('/', methods=['GET', 'POST'])
def index():
    if request.method == 'POST':
        start_class = request.form['start_class']
        target_class = request.form['target_class']

        # Create the graph object
        @app.route('/', methods=['GET', 'POST'])
def index():
    if request.method == 'POST':
        start_class = request.form['start_class']
        target_class = request.form['target_class']

        # Create the graph object
        graph = Graph({
        'ALL': ['EXP', 'Ppoly'],
        'AM': ['SZK', 'MA'],
        'BPP': ['P'],
        'BQP': ['BPP'],
        'coNP': ['P'],
        'EXP': ['PSPACE'],
        'L': ['AC0'],
        'MA': ['BPP', 'NP'],
        'NC': ['L'],
        'NP': ['P'],
        'P': ['NC'],
        'PH': ['AM', 'coNP'],
        'PP': ['BQP', 'MA', 'coNP'],
        'Ppoly': ['BPP'],
        'PSPACE': ['P#P'],
        'P#P': ['PH', 'PP']
    })

        # Dictionary to store the messages for each class relation
        messages = {('P', 'NP'): 'There exists an oracle w.r.t which P is not equal to NP',
            ('NP','P'): 'There exists an oracle w.r.t which P is not equal to NP',
           ('PH','NP'): 'There exists an oracle w.r.t which PH is not equal to NP',
            ('NP','PH'): 'There exists an oracle w.r.t which PH is not equal to NP',
           ('PH','P'): 'There exists an oracle w.r.t which PH is not equal to P',
            ('P','PH'): 'There exists an oracle w.r.t which PH is not equal to P',
           ('BQP', 'PH'): 'There exists an oracle w.r.t which BQP is not equal to PH',
            ('PH','BQP'): 'There exists an oracle w.r.t which BQP is not equal to PH',
           ('BQP','QCMA'): 'There exists an oracle w.r.t which BQP is equal to QCMA',
            ('QCMA','BQP'): 'There exists an oracle w.r.t which BQP is equal to QCMA',
           ('BQP','BPP'): 'There exists an oracle w.r.t which BPP is not equal to BQP',
            ('BPP','BQP'): 'There exists an oracle w.r.t which BPP is not equal to BQP',
           ('NP','BQP'): 'There exists an oracle w.r.t which NP is not equal to BQP',
            ('BQP','NP'): 'There exists an oracle w.r.t which NP is not equal to BQP',
           ('PPAD','BQP'): 'There exists an oracle relative to which PPAD is not contained in BQP',
            ('BQP','PPAD'):'There exists an oracle relative to which PPAD is not contained in BQP',
           ('PPP','PPAD'): 'There exists an oracle relative to which PPP is not contained in PPAD',
            ('PPAD','PPP'):'There exists an oracle relative to which PPP is not contained in PPAD'}

        # Dictionary to store the messages for each class
        class_messages =class_messages = {
        'ALL': 'This is the class message for ALL.',
        'AM': 'This is the class message for AM.',
        'BPP': 'This is the class message for BPP.',
        # ... (add more class messages as needed)
    }

        # Find the shortest path between two classes
        shortest_path = find_shortest_path(graph, start_class, target_class)

        if shortest_path:
            # Reverse the order of the shortest path
            shortest_path.reverse()
            path_string = "âŠ†".join(shortest_path)
            messages_list = []

            for i in range(len(shortest_path) - 1):
                message = messages.get((shortest_path[i], shortest_path[i + 1]))
                if message:
                    messages_list.append(message)

            # Get class messages
            class_messages_list = []
            for node in [start_class, target_class]:
                class_msg = class_messages.get(node)
                if class_msg:
                    class_messages_list.append(f"{node}: {class_msg}")

            return render_template('result.html', path=path_string, messages=messages_list, class_messages=class_messages_list)

        else:
            return render_template('result.html', error="No known relation exists between {} and {}.".format(start_class, target_class))

    return render_template('index.html')