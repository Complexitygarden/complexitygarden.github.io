# -*- coding: utf-8 -*-
"""Untitled1.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1QnaADjwQg7eqlu8VeYFJKY1kU8mnPzoB
"""

from collections import deque

class Graph:
    def __init__(self, graph_dict):
        self.graph = graph_dict
        self.messages = {}

    def add_edge(self, node, neighbors):
        self.graph[node] = neighbors

    def remove_edge(self, node, neighbor):
        if node in self.graph and neighbor in self.graph[node]:
            self.graph[node].remove(neighbor)

    def add_message(self, node_pair, message):
        self.messages[node_pair] = message

    def remove_message(self, node_pair):
        if node_pair in self.messages:
            del self.messages[node_pair]

    def update_edge(self, node, new_neighbors):
        self.graph[node] = new_neighbors

    def get_neighbors(self, node):
        return self.graph.get(node, [])

    def get_message(self, node_pair):
        return self.messages.get(node_pair, None)

    def __str__(self):
        return f"Graph: {self.graph}\nMessages: {self.messages}"

def find_shortest_path(graph, start, target):
    queue = deque([(start, [])])
    visited = set()

    while queue:
        node, path = queue.popleft()
        visited.add(node)

        for neighbor in graph.get_neighbors(node):
            if neighbor == target:
                return path + [node, neighbor]
            if neighbor not in visited:
                queue.append((neighbor, path + [node]))

    return None
# Function to update the relations in the graph based on user input
def update_relations(graph):
    while True:
        node = input("Enter a node to update relations (or type 'done' to finish):")
        if node.lower() == 'done':
            break
        neighbors = input(f"Enter neighbors for '{node}' separated by spaces:")
        neighbors_list = neighbors.split()
        graph.update_edge(node, neighbors_list)

# Function to take the starting and target classes from the user
def get_start_and_target_classes():
    start_class = input("Enter the starting class:")
    target_class = input("Enter the target class:")
    return start_class, target_class

# Main code
if __name__ == "__main__":
    # Create the graph object
    graph = Graph({
        'ALL': ['EXP', 'Ppoly'],
        'AM': ['SZK', 'MA'],
        'BPP': ['P'],
        'BQP': ['BPP'],
        'coNP': ['P'],
        'EXP': ['PSPACE'],
        'L': ['AC0'],
        'MA': ['BPP', 'NP'],
        'NC': ['L'],
        'NP': ['P'],
        'P': ['NC'],
        'PH': ['AM', 'coNP'],
        'PP': ['BQP', 'MA', 'coNP'],
        'Ppoly': ['BPP'],
        'PSPACE': ['P#P'],
        'P#P': ['PH', 'PP']
    })

    # Dictionary to store the messages for each class relation
    messages = {('P', 'NP'): 'There exists an oracle w.r.t which P is not equal to NP',
            ('NP','P'): 'There exists an oracle w.r.t which P is not equal to NP',
           ('PH','NP'): 'There exists an oracle w.r.t which PH is not equal to NP',
            ('NP','PH'): 'There exists an oracle w.r.t which PH is not equal to NP',
           ('PH','P'): 'There exists an oracle w.r.t which PH is not equal to P',
            ('P','PH'): 'There exists an oracle w.r.t which PH is not equal to P',
           ('BQP', 'PH'): 'There exists an oracle w.r.t which BQP is not equal to PH',
            ('PH','BQP'): 'There exists an oracle w.r.t which BQP is not equal to PH',
           ('BQP','QCMA'): 'There exists an oracle w.r.t which BQP is equal to QCMA',
            ('QCMA','BQP'): 'There exists an oracle w.r.t which BQP is equal to QCMA',
           ('BQP','BPP'): 'There exists an oracle w.r.t which BPP is not equal to BQP',
            ('BPP','BQP'): 'There exists an oracle w.r.t which BPP is not equal to BQP',
           ('NP','BQP'): 'There exists an oracle w.r.t which NP is not equal to BQP',
            ('BQP','NP'): 'There exists an oracle w.r.t which NP is not equal to BQP',
           ('PPAD','BQP'): 'There exists an oracle relative to which PPAD is not contained in BQP',
            ('BQP','PPAD'):'There exists an oracle relative to which PPAD is not contained in BQP',
           ('PPP','PPAD'): 'There exists an oracle relative to which PPP is not contained in PPAD',
            ('PPAD','PPP'):'There exists an oracle relative to which PPP is not contained in PPAD'}

    # Dictionary to store the messages for each class
    class_messages = {
        'ALL': 'This is the class message for ALL.',
        'AM': 'This is the class message for AM.',
        'BPP': 'This is the class message for BPP.',
        # ... (add more class messages as needed)
    }

    # Update the relations in the graph
    update_relations(graph)

    # Get starting and target classes from the user
    start_class, target_class = get_start_and_target_classes()

    # Find the shortest path between two classes
    shortest_path = find_shortest_path(graph, start_class, target_class)

    if shortest_path:
        # Reverse the order of the shortest path
        shortest_path.reverse()
        print("Shortest path:", "âŠ†".join(shortest_path))
        for i in range(len(shortest_path) - 1):
            message = messages.get((shortest_path[i], shortest_path[i + 1]))
            if message:
                print(f"Oracle Separation from {shortest_path[i]} to {shortest_path[i + 1]}: {message}")

        # Print messages associated with both the starting and target classes
        for node in [start_class, target_class]:
            class_msg = class_messages.get(node)
            if class_msg:
                print(f" {node}: {class_msg}")
    else:
        print(f"No known relation exists between {start_class} and {target_class}.")
