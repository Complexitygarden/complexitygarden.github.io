{
    "class_list":{
        "ALL": {
            "name": "ALL",
            "latex_name": "\\mathsf{ALL}",
            "top": true,
            "description": "The class of all languages.",
            "information": "ALL is the complexity class of all languages. <br>It has shown that various non-uniform classes are equal to ALL, such as $\\mathsf{PP/rpoly}$, $\\mathsf{PostBQP/qpoly}$ [Aar04], $\\mathsf{QIP/qpoly}$ [Raz05] and $\\mathsf{PDQP/qpoly}$ [Aar18]."
        },
        "NONE": {
            "name": "NONE",
            "latex_name": "\\mathsf{NONE}",
            "bottom": true,
            "description": "The class of no languages.",
            "information": "The 'empty set' of complexity theory, NONE contains no languages but is not equal to the complement of ALL since $\\mathsf{coALL} = ALL$ ."
        },
        "PP": {
            "name": "PP",
            "latex_name": "\\mathsf{PP}",
            "description": "Probabilistic Polynomial Time",
            "information": "The class of decision problems solvable by an NP machine such that <br> <br> <ul> <li> If the answer is yes, then at least half of the computational paths accept </li> <li> If the answer is no, then less than half of the computational paths accept.</li></ul>"
        },
        "QMA": {
            "name": "QMA",
            "latex_name": "\\mathsf{QMA}",
            "description": "Quantum Merlin-Arthur",
            "information": "The class of decision problems such that 'yes' instances can be verified efficiently. That is: <br> <br> <ul> <li>If the answer is 'yes', then there exists a quantum state such that the verifier accepts with probability at least 2/3</li> <li>If the answer is 'no', then for all quantum states the verifier rejects with probability at least 2/3.</li></ul>"
        },
        "QCMA": {
            "name": "QCMA",
            "latex_name": "\\mathsf{QCMA}",
            "description": "Quantum Classical Merlin-Arthur",
            "information": "The class of decision problems for which a 'yes' answer can be efficiently verified by a family of uniform quantum circuits with access to a classical proof. Concretely: <br> <br> <ul> <li>For all 'yes' instances, there exists a poly(|x|) size classical proof such that the verifier accepts with probability at least 2/3</li> <li> For a 'no' instance, for all such classical proofs the verifier rejects with probability at least 2/3.</li></ul>"
        },
        "QIP": {
            "name": "QIP",
            "latex_name": "\\mathsf{QIP}",
            "description": "Quantum Interactive Proof",
            "information": "The class QIP is the quantum computing analogue of the classical complexity class IP, <br> <br> <ul> <li></li></ul><br>For more check out: <a href='https://complexityzoo.net/Complexity_Zoo:Q#qip'>Complexity Zoo</a>"
        },
        "PDQP": {
            "name": "PDQP",
            "latex_name": "\\mathsf{PDQP}",
            "description": "Polynomial Dynamical Quantum Polynomial Time",
            "information": "Generalization of BQP where the machine is allowed to perform measurements without collapsing the wavefunction. Defined in [ABFL16]. <br> PDQP may perform unordered search faster than BQP and contains SZK."
        },
        "P": {
            "name": "P",
            "latex_name": "\\mathsf{P}",
            "description": "Polynomial Time",
            "information": "The class of decision problems solveable in polynomial time by a Turing machine. Defined in [Edm65], [Cob64], [Rab60], and other early seminal papers."
        },
        "BQP": {
            "name": "BQP",
            "latex_name": "\\mathsf{BQP}",
            "description": "Bounded-Error Quantum Polynomial Time",
            "information": "The class of decision problems solvable in polynomial time by a quantum Turing machine. Specifically: <br><br><ul> <li>On 'yes' instances, the verifier accepts with probability at least 2/3. </li> <li> On 'no' instances, the verifier rejects with probability at least 2/3."
        },
        "NP": {
            "name": "NP",
            "latex_name": "\\mathsf{NP}",
            "description": "Non-deterministic Polynomial Time",
            "information": "The class of decision problems for which 'yes' answers are efficiently verifiable. Specifically: <br><br> <ul> <li> There exists a proof for all 'yes' instances such that the verifier accepts wih certainty. </li> <li>If an input is a 'no' instance, then the verifier rejects for all proofs. </li></ul>",
            "coClass": "coNP"
        },
        "SZK": {
            "name": "SZK",
            "latex_name": "\\mathsf{SZK}",
            "description": "Statistical Zero-Knowledge",
            "information": "The class of decision problems for which a 'yes' instance can be verified by a statistical zero knowledge proof protocol. This is an interactive protocol in which we have a probabilistic polynomia-time verifier and a prover with unbounded resources. Through exchanging messages with the prover, the verifier must be convinced of a 'yes' instance without learning anything about the proof."
        },
        "BPP": {
            "name": "BPP",
            "latex_name": "\\mathsf{BPP}",
            "description": "Bounded-Error Probabilistic Polynomial Time",
            "information": "The class of decision problems solvable by a nondeterministic Turing machine such that <br><br> <ul><li>If we are given a 'yes' instance, then the probability that we accpet is at least 2/3. </li><li> If we are given a 'no' instance, then we reject with probability at least 2/3.</li></ul>"
        },
        "PSPACE": {
            "name": "PSPACE",
            "latex_name": "\\mathsf{PSPACE}",
            "description": "Polynomial Space",
            "information": "The class of decision problems solvable by a Turing machine with polynomial space."
        },
        "EXP": {
            "name": "EXP",
            "latex_name": "\\mathsf{EXP}",
            "description": "Exponential Time",
            "information": "The class of decision problems solvable by a Turing machine in exponential time. Specifically, solvable in time $O(2^{p(n)})$ for any polynomial p."
        },
        "DQP":{
            "name": "DQP",
            "latex_name": "\\mathsf{DQP}",
            "description": "Dynamical Quantum Polynomial-Time",
            "information": "The class of problems solvable by a quantum computer with access to a dynamical simulator. The simulator provides a sample from the probability distribution of all possible classical histories that (sequences of measurement outcomes) that could arise from running a given quantum circuit. Proposed to explore the power of hidden-variable quantum models."
        },
        "L": {
            "name": "L",
            "latex_name": "\\mathsf{L}",
            "description": "Logarithmic Space",
            "information":"Class of decision problems solvable by a Turing machine restricted to a memory of logarithmic size in terms of the input size n. Note that the input is not part of the memory."
        },
        "NL":{
            "name": "NL",
            "latex_name": "\\mathsf{NL}",
            "description": "Non-deterministic Logarithmic Space",
            "information": "The Non-deterministic version of L."
        },
        "MA":{
            "name": "MA",
            "latex_name": "\\mathsf{MA}",
            "description": "Merlin-Arthur",
            "information": "Class of decision problems solvable by a Merlin-Arthur protocol. A probabilistic version of NP. Similar to AM, except Arthur does not send a question to Merlin and Merlin simply provides a \"proof\"."
        },
        "AM": {
            "name": "AM",
            "latex_name": "\\mathsf{AM}",
            "description": "Arthur-Merlin",
            "information": "Class of decision problems solvable by a Arthur-Merlin protocol. In this protocol, Arthur, a BPP machine, generates a \"question\" which he sends to Merlin, an all-powerful being. Merlin sends back a response which Arthur uses to decide the answer. If the answer is 'yes', then Arthur accepts with probability at least 2/3. If the answer is 'no', then Arthur rejects with probability at least 2/3."
        },
        "QMA(2)": {
            "name": "QMA(2)",
            "latex_name": "\\mathsf{QMA(2)}",
            "description": "Quantum Merlin-Arthur with two unentangled certificates.",
            "information": "For $k\\geq 2$, $\\mathsf{QMA(2)}=\\mathsf{QMA(k)}$ where $\\mathsf{QMA(k)}$ is the class with $k$ unentangled certificates."
        },
        "NEXP":{
            "name": "NEXP",
            "latex_name": "\\mathsf{NEXP}",
            "description": "Non-deterministic Exponential Time",
            "information": "The class of languages decidable by a non-deterministic Turing machine in time $2^{p(n)}$ for some polynomial p."
        },
        "RE":{
            "name": "RE",
            "latex_name": "\\mathsf{RE}",
            "description": "Recursive Enumerable Languages",
            "information": "Class of decision problems for which a 'yes' answer may be verified by a Turing machine in a finite amount of time, while if the answer is 'no' the machine may never halt."
        },
        "A0PP":{
            "name": "A0PP",
            "latex_name": "\\mathsf{A_{0}PP}",
            "description": "One-Sided Analog of AWPP",
            "information": "A class defined using the output of GapP functions with a one-sided gap: zero for 'no' instances and exponentially large for 'yes' instances."
        },
        "AWPP":{
            "name": "AWPP",
            "latex_name": "\\mathsf{AWPP}",
            "description": "Almost WPP",
            "information": "A class defined using the output of GapP functions with bounded acceptance probabilities."
        },
        "R":{
            "name": "R",
            "latex_name": "\\mathsf{R}",
            "description": "Recursive Languages",
            "information": "The class of decision problems solvable by a Turing Machine. Defined in [Tur36] and [Chu41]."
        },
        "RP":{
            "name": "RP",
            "latex_name": "\\mathsf{RP}",
            "description": "Randomized Polynomial Time",
            "information": "The class of decision problems solvable by a probabilistic Turing machine in polynomial time such that if the answer is \"yes\", then the machine accepts with probability at least 1/2. If the answer is \"no\", the machine always rejects."
        },
        "ZPP":{
            "name": "ZPP",
            "latex_name": "\\mathsf{ZPP}",
            "description": "Zero-Error Probabilistic Polynomial Time",
            "information": "The class of decision problems solvable by a randomized algorithm that always gives the correct answer and runs in expected polynomial time. Guarantees zero error, unlike RP and BPP. "
        },
        "CH":{
            "name": "CH",
            "latex_name": "\\mathsf{CH}",
            "description": "Counting Hierarchy",
            "information": " The counting hierarchy is an analog of the polynomial hierarchy using PP instead of NP. The hierarchy is equivalent to a tower of PP oracles. For example $C_1H = PP$, $C_2H = PP^{PP}$, $C_3H = PP^{PP^{PP}}$ and so on. The class CH is the union over all of these."
        },
        "PH":{
            "name": "PH",
            "latex_name": "\\mathsf{PH}",
            "description": "Polynomial Hierarchy",
            "information": "A hierarchy of complexity classes that can be defined by applying a sequence of existential and universal quantifiers to a polynomial-time predicate. The hierarchy is equivalent to a tower of NP oracles with constant height - $NP^{NP^{NP^{...^{NP}}}}$. Includes coNP and levels like $\\mathsf{\\Sigma_{k}^{p}}$ and $\\mathsf{\\Pi_{k}^{p}}$."
        },
        "Sigma2":{
            "name": "Sigma2",
            "latex_name": "\\mathsf{\\Sigma_{2}^{p}}",
            "description": "NP with an NP oracle",
            "information": "Together with Pi2 comprises the second level of the polynomial hierarchy."
        },
        "Pi2":{
            "name": "Pi2",
            "latex_name": "\\mathsf{\\Pi_{2}^{p}}",
            "description": "co-NP with an NP oracle",
            "information": "Together with Sigma2 comprises the second level of the polynomial hierarchy."
        },
        "AC0":{
            "name":"AC0",
            "latex_name":"\\mathsf{AC^0}",
            "description":"The class of constant-depth, polynomial-size circuits with unbounded fan-in AND, OR, and NOT gates.",
            "information":"The smallest class in the AC hierarchy. Consists of all families of circuits of constant depth and polynomial size, with unbounded fan-in AND, OR, and NOT gates. Integer addition and subtraction is computable in AC0, but multiplication is not."
        },
        "TC0":{
            "name":"TC0",
            "latex_name":"\\mathsf{TC^0}",
            "description":"The class of constant-depth, polynomial-size circuits with unbounded fan-in AND, OR, and MAJ (Majority) gates.",
            "information":"The smallest class in the TC hierarchy. Consists of all families of circuits of constant depth polynomial size, with unbounded fan-in AND, OR, NOT, and MAJ (Majority) gates. Contains several problems like sorting n n-bit numbers, multiplying two n-bit integers, and integer division. Commonly used to model the computational complexity of bounded-depth neural networks. Strictly more powerful than AC0."
        },
        "NC0":{
            "name":"NC0",
            "latex_name":"\\mathsf{NC^0}",
            "description":"The class of constant-depth, polynomial-size circuits with binary AND, OR gates and unary NOT gates.",
            "information":"The smallest class in the NC complexity class. Consists of all families of circuits of constant-depth, polynomial-size circuits with bounded fan-in AND, OR gates and NOT gates. Models extremely local computation."
        },
        "NC1":{
            "name":"NC1",
            "latex_name":"\\mathsf{NC^1}",
            "description":"The class of O(\\log (n)) depth, polynomial-size circuits with binary AND, OR gates and unary NOT gates.",
            "information":"Like NC0, but allows depths O(logn) instead of constant depth. Can compute things like integer addition, balanced parenthesis checking, and regular expression matching."
        },
        "AC1":{
            "name":"AC1",
            "latex_name":"\\mathsf{AC^1}",
            "description":"The class of O(\\log (n)) depth, polynomial-size circuits with unbounded fan-in AND, OR, and NOT gates.",
            "information":"Like AC0, but allows depths of O(logn) instead of constant depth."
        },
        "TC1":{
            "name":"TC1",
            "latex_name":"\\mathsf{TC^1}",
            "description":"The class of O(\\log (n)) depth, polynomial-size circuits with unbounded fan-in AND, OR, and MAJ (Majority) gates..",
            "information":"Like TC0, but allows depths O(logn) instead of constant depth."
        },
        "CZK":{
            "name":"CZK",
            "latex_name":"\\mathsf{CZK}",
            "description":"Computational Zero-Knowledge",
            "information":"The class of decision problems solvable by a zero-knowledge proof system where the distributions which the verifier can simulate are computationally indistinguishable from the distributions which the verifier can simulate through interaction with the prover."
        },
        "P/poly":{
            "name":"P/poly",
            "latex_name":"\\mathsf{P/poly}",
            "description":"P with polynomial advice",
            "information":"The class of decision problems solvable by a polynomial-time Turing machine with a polynomial-size advice string. Equals $\\mathsf{BPP/poly}$."
        },
        "BQP/poly":{
            "name":"BQP/poly",
            "latex_name":"\\mathsf{BQP/poly}",
            "description":"BQP with polynomial advice",
            "information":"The class of decision problems solvable by a BQP machine with a polynomial-size advice string with probability at least $2/3$, even if the advice is bad."
        },
        "BQP/qpoly":{
            "name":"BQP/qpoly",
            "latex_name":"\\mathsf{BQP/qpoly}",
            "description":"BQP with polynomial quantum advice",
            "information":"The class of decision problems solvable by a polynomial-time quantum Turing machine with a polynomial-size advice quantum state."
        },
        "QCPH":{
            "name":"QCPH",
            "latex_name":"\\mathsf{QCPH}",
            "description":"Quantum-Classical Polynomial Hierarchy",
            "information":"The class of languages solvable by a constant number of alternating classical quantifiers followed by a quantum verifier.\n Defined in [GSSSY18]. "
        },
        "QPH":{
            "name":"QPH",
            "latex_name":"\\mathsf{QPH}",
            "description":"Quantum Polynomial Hierarchy",
            "information":"A generalization of PH where the verifier is a quantum circuit and the proofs are quantum states. More formally, the class of languages solvable by a constant number of alternating quantum quantifiers followed by a quantum verifier\n Defined in [GSSSY18]."
        },
        "IP":{
            "name":"IP",
            "latex_name":"\\mathsf{IP}",
            "description":"Interactive Proof System",
            "information":"The class of problems solvable by an interactive proof system with a probabilistic polynomial time (BPP) verifier and an unbounded prover for a polynomial number of rounds. Equal to PSPACE [Sha92]."
        },
        "BPPPath":{
            "name":"BPPPath",
            "latex_name":"\\mathsf{BPP_{\\text{path}}}",
            "description":"Threshold BPP",
            "information":"Also known as PostBPP."
        },
        "MIP":{
            "name":"MIP",
            "latex_name":"\\mathsf{MIP}",
            "description":"Multi-Prover Interactive Proof System",
            "information":"Similar to IP, except there are multiple provers, and the verifier can exchange messages with many provers. The provers cannot communicate with one another. Equal to NEXP [BFL91]."
        },
        "MIPStar":{
            "name":"MIPStar",
            "latex_name":"\\mathsf{MIP^{*}}",
            "description":"MIP with Quantum Provers",
            "information":"MIP with Quantum provers. Similar to MIP, except the provers can share arbitrarily many entangled qubits. The verifier, and all messages between provers and verifiers are classical. Equal to RE."
        },
        "PostBQP":{
            "name":"PostBQP",
            "latex_name":"\\mathsf{PostBQP}",
            "description":"PostBQP",
            "information":"Equal to PP."
        },
        "EQP":{
            "name":"EQP",
            "latex_name":"\\mathsf{EQP}",
            "description":"Exact Quantum Polynomial Time",
            "information":"Same as BQP, except we output the correct answer with probability 1."
        },
        "LWPP":{
            "name":"LWPP",
            "latex_name":"\\mathsf{LWPP}",
            "description":"Length-Dependent Wide $\\mathsf{PP}$",
            "information":" A class defined using GapP functions where the gap depends only on input length."
        },
        "CL":{
            "name":"CL",
            "latex_name":"\\mathsf{CL}",
            "description":"Catalytic Logarithmic Space",
            "information":"A class that extends L by allowing a polynomial-sized tape called a catalytic tape. The tape can is read/write during computation but must be restored to its original state at the end of computation. The logarithmic space bound still applies to the primary (non-catalytic) work tape."
        },
        "QMA1":{
            "name":"QMA1",
            "latex_name":"\\mathsf{QMA_{1}}",
            "description":"One-sided $\\mathsf{QMA}$",
            "information":"QMA, except for a \"yes\" instance, there exists a state which is accepted with probability 1. It has been shown that Quantum k-SAT is $\\mathsf{QMA_{1}}$-complete for $k\\geq 3.$"
        },
        "AH":{
            "name":"AH",
            "latex_name":"\\mathsf{AH}",
            "description":"Arithmetic Hierarchy",
            "information":"Analog of PH in computability theory."
        },
        "SBQP":{
            "name":"SBQP",
            "latex_name":"\\mathsf{SBQP}",
            "description":"Small Bounded-Error Quantum Polynomial-Time",
            "information":"The class of decision problems for which there exists a polynomial-time quantum algorithm which for some polynomial $p(n)$: <br><br> <ul> <li> If the answer is 'yes', then the algorithm accepts with probability at least $2^{-p(n)}$. </li> <li> If the answer is 'no', then the algorithm accepts with probability at most $2^{-p(n)-1}$. </li></ul>"
        },
        "SBP":{
            "name":"SBP",
            "latex_name":"\\mathsf{SBP}",
            "description":"Small Bounded-Error Probabilistic Polynomial-Time",
            "information":"The class of decision problems for which there exists some $\\mathsf{\\#P}$ function $f$ and $\\mathsf{FP}$ function $g$ such that <br><br> <ul> <li> If the answer is 'yes', then $f(x) > g(x)$ </li> <li> If the answer is 'no', then $f(x) < g(x)/2$ </li></ul>"
        },
        "PP/poly":{
            "name":"PP/poly",
            "latex_name":"\\mathsf{PP/poly}",
            "description":"Nonuniform $\\mathsf{PP}$",
            "information":"PP with polynomial advice."
        },
        "CequalsP":{
            "name":"CequalsP",
            "latex_name":"\\mathsf{C_{=}P}",
            "description":"Exact-Counting Polynomial-Time",
            "information":"The class of decision problems solvable by an NP machine such that the number of accepting paths exactly equals the number of rejecting paths, if and only if the answer is 'yes.'"
        },
        "BQP/mpoly":{
            "name":"BQP/mpoly",
            "latex_name":"\\mathsf{BQP/mpoly}",
            "description":"BQP with polynomial merlin-like advice",
            "information":"The class of decision problems solvable by a BQP machine with a polynomial-size advice string with probability at least $2/3$ when the advice is good."
        },
        "PsharpP":{
            "name":"PsharpP",
            "latex_name":"\\mathsf{P^{\\#P}}",
            "description":"P with #P oracle",
            "information":"The class of decision problems solvable by a P machine with a #P oracle. Equals $\\mathsf{P^{\\mathsf{PP}}}$.<br>Contains PH. [Tod91]."
        },
        "coNP":{
            "name":"coNP",
            "latex_name":"\\mathsf{coNP}",
            "description":"Complement of $\\mathsf{NP}$",
            "information":"The class of decision problems for which 'no' answers are efficiently verifiable. Specifically: <br><br> <ul> <li> There exists a proof for all 'no' instances such that the verifier accepts wih certainty. </li> <li>If an input is a 'yes' instance, then the verifier rejects for all proofs. </li></ul>",
            "coClass": "NP"
        },
        "QCMA/poly":{
            "name":"QCMA/poly",
            "latex_name":"\\mathsf{QCMA/poly}",
            "description":"QCMA with polynomial size advice",
            "information":"QCMA with polynomial size advice"
        },
        "QCMA/qpoly":{
            "name":"QCMA/qpoly",
            "latex_name":"\\mathsf{QCMA/qpoly}",
            "description":"QCMA with polynomial size quantum advice",
            "information":"QCMA with polynomial size quantum advice"
        },
        "QMA/poly":{
            "name":"QMA/poly",
            "latex_name":"\\mathsf{QMA/poly}",
            "description":"QMA with polynomial size advice",
            "information":"QMA with polynomial size advice"
        },
        "QMA/qpoly":{
            "name":"QMA/qpoly",
            "latex_name":"\\mathsf{QMA/qpoly}",
            "description":"QMA with polynomial quantum size advice",
            "information":"QMA with polynomial quantum size advice"
        },
        "PSPACE/poly":{
            "name":"PSPACE/poly",
            "latex_name":"\\mathsf{PSPACE/poly}",
            "description":"PSPACE with polynomial size advice",
            "information":"PSPACE with polynomial size advice"
        },
        "BQPSPACE/qpoly":{
            "name":"BQPSPACE/qpoly",
            "latex_name":"\\mathsf{BQPSPACE/qpoly}",
            "description":"BQPSPACE with polynomial quantum size advice",
            "information":"BQPSPACE with polynomial quantum size advice."
        },
        "QAM": {
            "name":"QAM",
            "latex_name":"\\mathsf{QAM}",
            "description":"Quantum Arthur-Merlin",
            "information":"A quantum version of the Arthur-Merlin protocol. Specifically, Arthur flips several coins, sends their results to Merlin, and Merlin responds with a quantum state. Arthur's verification protocol takes the coin flips and Merlin's quantum state as input."
        },
        "QIP[2]": {
            "name":"QIP[2]",
            "latex_name":"\\mathsf{QIP[2]}",
            "description":"QIP with Two Messages.",
            "information":"Quantum Interactive Proof system with two messages exchanged between the prover and the verifier."
        },
        "BQPSPACE":{
            "name":"BQPSPACE",
            "latex_name":"\\mathsf{BQPSPACE}",
            "description":"Bounded-Error Quantum PSPACE.",
            "information":"PSPACE, except the machine is a quantum Turing machine and the answer is correct with at least $2/3$ probability."
        },
        "BQPCTC":{
            "name":"BQPCTC",
            "latex_name":"\\mathsf{BQP_{CTC}}",
            "description":"BQP with Closed Timelike Curves",
            "information":"BQP with access to two types of qubits, casuality-respecting qubits and CTC qubits. It is equal to PSPACE [AW08]."
        },
        "PCTC":{
            "name":"PCTC",
            "latex_name":"\\mathsf{P_{CTC}}",
            "description":"P with Closed Timelike Curves",
            "information":"P with access to CTC bits. It is equal to PSPACE [AW08]."
        }
    }
}
