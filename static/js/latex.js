// Export current D3 graph into a standalone TikZ picture and download as .tex
// Requirements: the main force simulation created in graph.js must be accessible via the global `simulation` variable.
// Clicking the "Export to LaTeX" link in the sidebar triggers the export.

(function(){
    /** Escapes a string so that it can be used as a TikZ node identifier. */
    function makeNodeId(idx){
        return `N${idx}`; // simple, safe id
    }

    /** Build TikZ code for the current graph. */
    function buildTikz(){
        if (typeof simulation === 'undefined' || !simulation || !simulation.nodes){
            alert('No graph available to export.');
            return null;
        }

        const nodes = simulation.nodes();
        if (!nodes || nodes.length === 0){
            alert('No nodes found – draw a graph first.');
            return null;
        }

        // Extract links
        let links = [];
        const linkForce = simulation.force('links');
        if (linkForce && linkForce.links){
            links = linkForce.links();
        }

        // Determine bounding box to shift coordinates into positive region
        const minX = Math.min(...nodes.map(n => n.x));
        const minY = Math.min(...nodes.map(n => n.y));

        // Auto-scale so the largest dimension fits into `targetCm` centimetres
        const maxX = Math.max(...nodes.map(n => n.x));
        const maxY = Math.max(...nodes.map(n => n.y));
        const widthPx  = maxX - minX;
        const heightPx = maxY - minY;
        // Choose target size based on depth (levels). Fewer levels → smaller desired size.
        const levels = Math.max(...nodes.map(n => (typeof n.level === 'number' ? n.level : 0))) + 1;
        const targetCm = Math.min(10, 2 + levels * 1.5); // between 2 cm and 10 cm
        const scaleFactor = (targetCm / Math.max(widthPx, heightPx)).toFixed(4); // cm per px

        // Map node object reference to id index
        const nodeIdxMap = new Map();
        nodes.forEach((n, i) => nodeIdxMap.set(n, i));

        let tikz = '';
        tikz += '\\documentclass{article}\n';
        tikz += '\\usepackage{tikz}\n';
        tikz += '\\usepackage{amsmath}\n';
        tikz += '\\usepackage{graphicx}\n';
        tikz += '\\title{}\n';
        tikz += '\\author{}\n';
        tikz += '\\begin{document}\n';
        tikz += '% Generated by Complexity Garden – Export to LaTeX\n';
        tikz += '% Requires: \\usepackage{tikz}, \\usepackage{amsmath}, \\usepackage{graphicx}\n';
        tikz += '\n% Adjust overall size via the scale variable (1 = default)\n';
        tikz += '\n\\newcommand{\\graphscale}{1}% <- change this to scale the whole figure\n';
        tikz += '\n% Text size scaling (1 = default). Increase for larger labels relative to edges\n';
        tikz += '\n\\newcommand{\\graphnodescale}{1}% <- change this to enlarge text only\n';
        tikz += `\\begin{tikzpicture}[>=stealth, x=${scaleFactor}cm, y=${scaleFactor}cm, scale=\\graphscale, transform shape]\n`;

        // Emit nodes
        nodes.forEach((n, idx) => {
            const id = makeNodeId(idx);
            const x = (n.x - minX).toFixed(2);
            const y = (maxY - n.y).toFixed(2); // invert Y-axis for LaTeX (positive up)
            let labelParts = [n.latex_name || n.name || `C${idx}`];
            if (Array.isArray(n.equal_classes) && n.equal_classes.length > 0) {
                labelParts = labelParts.concat(n.equal_classes.map(eq => eq.latex_name || eq.name));
            }
            const label = labelParts.join(' = ');
            tikz += `  \\node (${id}) at (${x},${y}) {\\scalebox{\\graphnodescale}{$${label}$}};\n`;
        });

        tikz += '\n';

        // Emit edges
        links.forEach(l => {
            let srcIdx = nodeIdxMap.get(l.source);
            let tgtIdx = nodeIdxMap.get(l.target);
            // In case source/target stored as indices (after d3 internal re-link)
            if (srcIdx === undefined && typeof l.source === 'number') srcIdx = l.source;
            if (tgtIdx === undefined && typeof l.target === 'number') tgtIdx = l.target;
            if (srcIdx === undefined || tgtIdx === undefined) return; // skip if not found
            tikz += `  \\draw[->] (${makeNodeId(srcIdx)}) -- (${makeNodeId(tgtIdx)});\n`;
        });

        tikz += '\\end{tikzpicture}\n';
        tikz += '\\end{document}\n';
        return tikz;
    }

    function downloadContent(content, filename){
        const blob = new Blob([content], {type: 'text/x-tex'});
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = filename;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
    }

    function exportGraphToLaTeX(){
        const tikz = buildTikz();
        if (tikz){
            downloadContent(tikz, 'complexity_graph.tex');
        }
    }

    // Attach click handler after DOM ready
    document.addEventListener('DOMContentLoaded', function(){
        const linkEl = document.getElementById('export-latex-link');
        if (linkEl){
            linkEl.addEventListener('click', function(evt){
                evt.preventDefault();
                exportGraphToLaTeX();
            });
        }
    });
})(); 
